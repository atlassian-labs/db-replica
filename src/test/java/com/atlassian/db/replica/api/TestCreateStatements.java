package com.atlassian.db.replica.api;

import com.atlassian.db.replica.api.mocks.ConnectionProviderMock;
import org.junit.jupiter.api.Test;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import static com.atlassian.db.replica.api.Queries.SIMPLE_QUERY;
import static com.atlassian.db.replica.api.mocks.CircularConsistency.permanentConsistency;
import static org.mockito.Mockito.verify;

public class TestCreateStatements {

    @Test
    public void shouldPrepareStatementWhenExecute() throws SQLException {
        final ConnectionProviderMock connectionProvider = new ConnectionProviderMock();
        final Connection connection = DualConnection.builder(
            connectionProvider,
            permanentConsistency().build()
        ).build();

        connection.prepareStatement(SIMPLE_QUERY).execute();

        verify(connectionProvider.singleProvidedConnection()).prepareStatement(SIMPLE_QUERY);
    }

    @Test
    public void shouldPrepareStatementWithAutoGeneratedKeys() throws SQLException {
        final ConnectionProviderMock connectionProvider = new ConnectionProviderMock();
        final Connection connection = DualConnection.builder(
            connectionProvider,
            permanentConsistency().build()
        ).build();
        final int autoGeneratedKeys = Statement.RETURN_GENERATED_KEYS;

        connection.prepareStatement(SIMPLE_QUERY, autoGeneratedKeys).execute();

        verify(connectionProvider.singleProvidedConnection()).prepareStatement(SIMPLE_QUERY, autoGeneratedKeys);
    }

    @Test
    public void shouldPrepareStatementWithColumnNames() throws SQLException {
        final ConnectionProviderMock connectionProvider = new ConnectionProviderMock();
        final Connection connection = DualConnection.builder(
            connectionProvider,
            permanentConsistency().build()
        ).build();
        final String[] columnNames = {"test"};

        connection.prepareStatement(SIMPLE_QUERY, columnNames).execute();

        verify(connectionProvider.singleProvidedConnection()).prepareStatement(SIMPLE_QUERY, columnNames);
    }

    @Test
    public void shouldPrepareStatementWithColumnIndexes() throws SQLException {
        final ConnectionProviderMock connectionProvider = new ConnectionProviderMock();
        final Connection connection = DualConnection.builder(
            connectionProvider,
            permanentConsistency().build()
        ).build();
        final int[] columnIndexes = {123};

        connection.prepareStatement(SIMPLE_QUERY, columnIndexes).execute();

        verify(connectionProvider.singleProvidedConnection()).prepareStatement(SIMPLE_QUERY, columnIndexes);
    }

    @Test
    public void shouldPrepareStatementWithResultSetConcurrency() throws SQLException {
        final ConnectionProviderMock connectionProvider = new ConnectionProviderMock();
        final Connection connection = DualConnection.builder(
            connectionProvider,
            permanentConsistency().build()
        ).build();
        final int resultSetType = ResultSet.TYPE_FORWARD_ONLY;
        final int resultSetConcurrency = ResultSet.CONCUR_READ_ONLY;

        connection.prepareStatement(SIMPLE_QUERY, resultSetType, resultSetConcurrency).execute();

        verify(connectionProvider.singleProvidedConnection()).prepareStatement(
            SIMPLE_QUERY,
            resultSetType,
            resultSetConcurrency
        );
    }

    @Test
    public void shouldPrepareStatementWithResultSetHoldability() throws SQLException {
        final ConnectionProviderMock connectionProvider = new ConnectionProviderMock();
        final Connection connection = DualConnection.builder(
            connectionProvider,
            permanentConsistency().build()
        ).build();
        final int resultSetType = ResultSet.TYPE_FORWARD_ONLY;
        final int resultSetConcurrency = ResultSet.CONCUR_READ_ONLY;
        final int resultSetHoldability = ResultSet.CLOSE_CURSORS_AT_COMMIT;

        connection.prepareStatement(SIMPLE_QUERY, resultSetType, resultSetConcurrency, resultSetHoldability).execute();

        verify(connectionProvider.singleProvidedConnection()).prepareStatement(
            SIMPLE_QUERY,
            resultSetType,
            resultSetConcurrency,
            resultSetHoldability
        );
    }

    @Test
    public void shouldCreateStatement() throws SQLException {
        final ConnectionProviderMock connectionProvider = new ConnectionProviderMock();
        final Connection connection = DualConnection.builder(
            connectionProvider,
            permanentConsistency().build()
        ).build();

        connection.createStatement().execute(SIMPLE_QUERY);

        verify(connectionProvider.singleProvidedConnection()).createStatement();
    }

    @Test
    public void shouldCreateStatementWithResultSetType() throws SQLException {
        final ConnectionProviderMock connectionProvider = new ConnectionProviderMock();
        final Connection connection = DualConnection.builder(
            connectionProvider,
            permanentConsistency().build()
        ).build();
        final int resultSetType = ResultSet.TYPE_FORWARD_ONLY;
        final int resultSetConcurrency = ResultSet.CONCUR_READ_ONLY;


        connection.createStatement(resultSetType, resultSetConcurrency).execute(SIMPLE_QUERY);

        verify(connectionProvider.singleProvidedConnection()).createStatement(resultSetType, resultSetConcurrency);
    }

    @Test
    public void shouldCreateStatementWithResultSetHoldability() throws SQLException {
        final ConnectionProviderMock connectionProvider = new ConnectionProviderMock();
        final Connection connection = DualConnection.builder(
            connectionProvider,
            permanentConsistency().build()
        ).build();
        final int resultSetType = ResultSet.TYPE_FORWARD_ONLY;
        final int resultSetConcurrency = ResultSet.CONCUR_READ_ONLY;
        final int resultSetHoldability = ResultSet.CLOSE_CURSORS_AT_COMMIT;

        connection.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability).execute(SIMPLE_QUERY);

        verify(connectionProvider.singleProvidedConnection()).createStatement(
            resultSetType,
            resultSetConcurrency,
            resultSetHoldability
        );
    }

    @Test
    public void shouldPrepareCall() throws SQLException {
        final ConnectionProviderMock connectionProvider = new ConnectionProviderMock();
        final Connection connection = DualConnection.builder(
            connectionProvider,
            permanentConsistency().build()
        ).build();

        connection.prepareCall(SIMPLE_QUERY).execute();

        verify(connectionProvider.singleProvidedConnection()).prepareCall(SIMPLE_QUERY);
    }

    @Test
    public void shouldPrepareCallWithResultSetType() throws SQLException {
        final ConnectionProviderMock connectionProvider = new ConnectionProviderMock();
        final Connection connection = DualConnection.builder(
            connectionProvider,
            permanentConsistency().build()
        ).build();
        final int resultSetType = 1;
        final int resultSetConcurrency = 2;

        connection.prepareCall(SIMPLE_QUERY, resultSetType, resultSetConcurrency).execute();

        verify(connectionProvider.singleProvidedConnection()).prepareCall(
            SIMPLE_QUERY,
            resultSetType,
            resultSetConcurrency
        );
    }

    @Test
    public void shouldPrepareCallWithResultSetHoldability() throws SQLException {
        final ConnectionProviderMock connectionProvider = new ConnectionProviderMock();
        final Connection connection = DualConnection.builder(
            connectionProvider,
            permanentConsistency().build()
        ).build();
        final int resultSetType = 1;
        final int resultSetConcurrency = 2;
        final int resultSetHoldability = 3;

        connection.prepareCall(SIMPLE_QUERY, resultSetType, resultSetConcurrency, resultSetHoldability).execute();

        verify(connectionProvider.singleProvidedConnection()).prepareCall(
            SIMPLE_QUERY,
            resultSetType,
            resultSetConcurrency,
            resultSetHoldability
        );
    }
}
