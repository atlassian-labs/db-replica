package com.atlassian.db.replica.api;

import com.atlassian.db.replica.api.mocks.ConnectionProviderMock;
import com.atlassian.db.replica.api.mocks.PermanentConsistency;
import org.junit.Test;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import static com.atlassian.db.replica.api.Queries.SIMPLE_QUERY;
import static org.mockito.Mockito.verify;

public class TestCreateStatements {
    private final ConnectionProviderMock connectionProvider = new ConnectionProviderMock();

    @Test
    public void shouldPrepareStatementWhenExecute() throws SQLException {
        final DualConnection connection = DualConnection.builder(connectionProvider, new PermanentConsistency()).build();

        connection.prepareStatement(SIMPLE_QUERY).execute();

        verify(connectionProvider.getProvidedConnections().get(0)).prepareStatement(SIMPLE_QUERY);
    }

    @Test
    public void shouldPrepareStatementWithAutoGeneratedKeys() throws SQLException {
        final DualConnection connection = DualConnection.builder(connectionProvider, new PermanentConsistency()).build();
        final int autoGeneratedKeys = Statement.RETURN_GENERATED_KEYS;

        connection.prepareStatement(SIMPLE_QUERY, autoGeneratedKeys).execute();

        verify(connectionProvider.getProvidedConnections().get(0)).prepareStatement(SIMPLE_QUERY, autoGeneratedKeys);
    }

    @Test
    public void shouldPrepareStatementWithColumnNames() throws SQLException {
        final DualConnection connection = DualConnection.builder(connectionProvider, new PermanentConsistency()).build();
        final String[] columnNames = {"test"};

        connection.prepareStatement(SIMPLE_QUERY, columnNames).execute();

        verify(connectionProvider.getProvidedConnections().get(0)).prepareStatement(SIMPLE_QUERY, columnNames);
    }

    @Test
    public void shouldPrepareStatementWithColumnIndexes() throws SQLException {
        final DualConnection connection = DualConnection.builder(connectionProvider, new PermanentConsistency()).build();
        final int[] columnIndexes = {123};

        connection.prepareStatement(SIMPLE_QUERY, columnIndexes).execute();

        verify(connectionProvider.getProvidedConnections().get(0)).prepareStatement(SIMPLE_QUERY, columnIndexes);
    }

    @Test
    public void shouldPrepareStatementWithResultSetConcurrency() throws SQLException {
        final DualConnection connection = DualConnection.builder(connectionProvider, new PermanentConsistency()).build();
        final int resultSetType = ResultSet.TYPE_FORWARD_ONLY;
        final int resultSetConcurrency = ResultSet.CONCUR_READ_ONLY;

        connection.prepareStatement(SIMPLE_QUERY, resultSetType, resultSetConcurrency).execute();

        verify(connectionProvider.getProvidedConnections().get(0)).prepareStatement(
            SIMPLE_QUERY,
            resultSetType,
            resultSetConcurrency
        );
    }

    @Test
    public void shouldPrepareStatementWithResultSetHoldability() throws SQLException {
        final DualConnection connection = DualConnection.builder(connectionProvider, new PermanentConsistency()).build();
        final int resultSetType = ResultSet.TYPE_FORWARD_ONLY;
        final int resultSetConcurrency = ResultSet.CONCUR_READ_ONLY;
        final int resultSetHoldability = ResultSet.CLOSE_CURSORS_AT_COMMIT;

        connection.prepareStatement(SIMPLE_QUERY, resultSetType, resultSetConcurrency, resultSetHoldability).execute();

        verify(connectionProvider.getProvidedConnections().get(0)).prepareStatement(
            SIMPLE_QUERY,
            resultSetType,
            resultSetConcurrency,
            resultSetHoldability
        );
    }

    @Test
    public void shouldCreateStatement() throws SQLException {
        final DualConnection connection = DualConnection.builder(connectionProvider, new PermanentConsistency()).build();

        connection.createStatement().execute(SIMPLE_QUERY);

        verify(connectionProvider.getProvidedConnections().get(0)).createStatement();
    }

    @Test
    public void shouldCreateStatementWithResultSetType() throws SQLException {
        final DualConnection connection = DualConnection.builder(connectionProvider, new PermanentConsistency()).build();
        final int resultSetType = ResultSet.TYPE_FORWARD_ONLY;
        final int resultSetConcurrency = ResultSet.CONCUR_READ_ONLY;


        connection.createStatement(resultSetType, resultSetConcurrency).execute(SIMPLE_QUERY);

        verify(connectionProvider.getProvidedConnections().get(0)).createStatement(resultSetType, resultSetConcurrency);
    }

    @Test
    public void shouldCreateStatementWithResultSetHoldability() throws SQLException {
        final DualConnection connection = DualConnection.builder(connectionProvider, new PermanentConsistency()).build();
        final int resultSetType = ResultSet.TYPE_FORWARD_ONLY;
        final int resultSetConcurrency = ResultSet.CONCUR_READ_ONLY;
        final int resultSetHoldability = ResultSet.CLOSE_CURSORS_AT_COMMIT;

        connection.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability).execute(SIMPLE_QUERY);

        verify(connectionProvider.getProvidedConnections().get(0)).createStatement(
            resultSetType,
            resultSetConcurrency,
            resultSetHoldability
        );
    }

    @Test
    public void shouldPrepareCall() throws SQLException {
        final DualConnection connection = DualConnection.builder(connectionProvider, new PermanentConsistency()).build();

        connection.prepareCall(SIMPLE_QUERY).execute();

        verify(connectionProvider.getProvidedConnections().get(0)).prepareCall(SIMPLE_QUERY);
    }

    @Test
    public void shouldPrepareCallWithResultSetType() throws SQLException {
        final DualConnection connection = DualConnection.builder(connectionProvider, new PermanentConsistency()).build();
        final int resultSetType = 1;
        final int resultSetConcurrency = 2;

        connection.prepareCall(SIMPLE_QUERY, resultSetType, resultSetConcurrency).execute();

        verify(connectionProvider.getProvidedConnections().get(0)).prepareCall(
            SIMPLE_QUERY,
            resultSetType,
            resultSetConcurrency
        );
    }

    @Test
    public void shouldPrepareCallWithResultSetHoldability() throws SQLException {
        final DualConnection connection = DualConnection.builder(connectionProvider, new PermanentConsistency()).build();
        final int resultSetType = 1;
        final int resultSetConcurrency = 2;
        final int resultSetHoldability = 3;

        connection.prepareCall(SIMPLE_QUERY, resultSetType, resultSetConcurrency, resultSetHoldability).execute();

        verify(connectionProvider.getProvidedConnections().get(0)).prepareCall(
            SIMPLE_QUERY,
            resultSetType,
            resultSetConcurrency,
            resultSetHoldability
        );
    }
}
